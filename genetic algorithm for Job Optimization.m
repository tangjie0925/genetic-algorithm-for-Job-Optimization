%Aim: 本程序用于计算最短路径，采用遗传算法进行实行
%Authors: Tang Jie & Guo Liping
clear
%车站与各作业点之间的走行时间的录入：
C=[0 42 28 35 30 25 20 22 25;
  42 0 16 27 31 52 48 55 68;
  28 16 0 19 24 45 37 56 44;
  35 27 19 0 43 38 19 50 55;
  30 31 24 43 0 36 26 44 51;
  25 52 45 38 36 0 18 30 39;
  20 48 37 19 26 18 0 27 33;
  22 55 56 50 44 30 27 0 21;
  25 68 44 55 51 39 33 21 0];
%当有n个点时的去送车方案
n=8;%n为作业点个数
p=50;%p为产生个体数
T=100;%T为进化代数
for i=1:n
  W(i)=i;%将作业地点看作1-n的序号，生成编码串W
end
for i=1:p%编码过程：每访问完一个作业地点，就从数组中去除
    for j=1:n
        s(i,j)=round(rand(1,1)*(n-j))+1; %矩阵s为随机生成的初始群体矩阵
    end
end
for k=1:T
    %解码过程：
    for i=1:p
        w=W;%为了不改变编码串将其复制为w，用w进行操作
        for j=1:n
            t(i,j)=w(s(i,j));%将每个个体解码
            w(s(i,j))=[];%每次删除翻译出的地点
        end
    end
    %各个方案下的时间花费：
    for i=1:p   %各个方案下的时间花费
        for j=1:n-1
             a(i)=C(1,t(i)+1);%原点到第一个点的时间
             b(i)=C(t(i,j+1)+1,1);%最后一点到原点的时间
             c(j)=C(t(i,j)+1,t(i,j+1)+1);%由方案矩阵与时间矩阵连接起来
             AA(i,1)=a(i)+sum(c)+b(i);%各个方案对应的时间存入AA矩阵
        end
    end
    %对个方案进行升序排列并存入矩阵A的第一列
    [A1,A2]=sort(AA);%A1为排序后结果，A2为在原矩阵的位置
    A(:,1)=A1;%A矩阵的第一列为排序后的目标值
    O(k,1)=A(1,1);%矩阵0为每代的最优目标值
    for i=1:p
        ss(i,:)=s(A2(i),:);%ss为初始矩阵按照目标值由小到大排列后的结果
    end
    %计算各方案适应度,并存入矩阵A的第二列中
    for i=1:p
        A(i,2)=410-A(i,1);
    end
    %各方案的概率存入A的第三列
    for i=1:p
        A(i,3)=A(i,2)/sum(A(:,2));
    end
    %求累计概率并存入矩阵A的第四列中
    A(1,4)=A(1,3);
    for i=2:p
        A(i,4)=A(i-1,4)+A(i,3);
    end
    %模拟赌盘操作来确定各个个体被选中的次数，并存入矩阵A的第五列
    A(1,5)=1;%保留该代中的最优个体
    A(2:p,5)=0;%将2-p行初始化为0
    for i=2:p
        d=rand(1,1);%产生0-1之间的随机数
        if d>A(1,4)
           for j=1:p-1
               if d>A(j,4)&&d<=A(j+1,4)
                  A(j+1,5)=A(j+1,5)+1;
               end
           end
        else A(1,5)=A(1,5)+1;
        end
    end
    %选择结果存入s1矩阵中
    s1=[];
    f=0;
    for i=1:p
        e=A(i,5);
        if e~=0
           for j=f+1:f+e
               s1(j,:)=ss(i,:);
           end
           f=f+e;
        end
    end
    %交叉过程-加入交叉概率pc
    %通过将产生的随机数与交叉概率进行比较来标记存入g，若大于pc，记为0，否则记为1，即要进行交叉
    pc=0.45; N=0;s11=[];s12=[];s13=[];
    g(1,1)=0;%保护最优个体
    s11(1,:)=s1(1,:);%s11矩阵中为不需要交叉的个体
    while N==0 %说明无配对现象，为了避免这种现象，重新选择交叉个体
          for i=2:p
              if rand(1,1)<=pc
                 g(i,1)=0;
                 s11(i,:)=s1(i,:);%将不需要交叉的个体存入s11中
              else
                 g(i,1)=1;
                 N=N+1;
                 s12(N,:)=s1(i,:);%将需要交叉的个体存入s12中，并且N为交叉个体数
                 NN=i;%NN为最后一个需要交叉个体s1中的位置，以便舍弃的时候放回原位置
              end
          end
          gg=g;
          if mod(N,2)~=0%判断是否出现奇数个个体
             s11(NN,:)=s12(N,:);%如果为奇数，将舍弃一个个体,并放回原位置
             gg(NN,1)=0;%gg为实际交叉情况
             N=N-1;%N为实际进行交叉的个体数
          end
    end
    B=reshape(randperm(N),N/2,2);%矩阵B为配对情况
    B(:,3)=round(rand(N/2,1)*(n-1))+1;%矩阵B的第三列为交叉点位置
    for i=(1:N/2)
        for j=1:2
            S(j,:)=s12(B(i,j),:);%从s12矩阵中读出2配对个体的串
        end
        S1=S(1,:);%将第一个串定义为S1
        S2=S(2,:);%将第二个串定义为S2
        x=[S1(1:B(i,3)) S2((B(i,3)+1):n)];%x为S1交叉后的新个体
        y=[S2(1:B(i,3)) S1((B(i,3)+1):n)];%y为S2交叉后的新个体
        s13(2*i-1,:)=x;%将交叉产生的新个体存入s13中
        s13(2*i,:)=y;
    end
    %交叉结果进行整理存入s2矩阵中
    s2=s11;%先存入没有交叉的个体
    J=0;
    for i=1:p
        if gg(i,:)==1
           J=J+1;
           s2(i,:)=s13(J,:);
        end
    end
    %变异过程
    pm=0.2; N=0;s21=[];s22=[];s23=[];
    h(1,1)=0;%保护最优个体
    s21(1,:)=s2(1,:);%s21矩阵中为不需要变异的个体
    for i=2:p
        if rand(1,1)<=pm
           h(i,1)=0;%不变异
           s21(i,:)=s2(i,:);%将不需要变异的个体存入s21中
        else
           h(i,1)=1;
           N=N+1;
           s22(N,:)=s2(i,:);%将需要变异的个体存入s22中，并且N为变异个体数
        end
    end  
    D=round(rand(N,1)*(n-1))+1;%矩阵D为变异点位置
    s23=s22;%防止将s22矩阵覆盖，用s23矩阵操作，最终形成s23矩阵表示变异产生的新个体
    for i=1:N
        for j=D(i):n
             s23(i,j)=round(rand(1,1)*(n-j))+1;%从变异点处开始开始重新编码形成新矩阵s22
        end
    end
    %变异结果进行整理存入s3矩阵中
    s3=s21;JJ=0;
    for i=1:p
        if h(i,:)==1
           JJ=JJ+1;
           s3(i,:)=s23(JJ,:);
        end
    end
    s=s3;%将子代群体赋值给s矩阵
end
fprintf('最优解为:%i\n',A(1,1))
fprintf('最优方案为：%s\n',num2str(t(A2(1,1),:)))
plot(O)
